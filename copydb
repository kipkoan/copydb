#!/bin/bash

E_OPTION_ERROR=1
E_INPUT_TYPE_ERROR=5
E_FAIL_ERROR=5
COMMAND=`basename $0`

# Set constants for formatting output
TXT_NORMAL=$(tput sgr0)
TXT_BOLD=$(tput bold)
TXT_COMMAND=$(tput setaf 4)
TXT_NOTICE=$(tput setaf 6)
TXT_SUCCESS=$(tput setaf 2)
TXT_WARNING=$(tput setaf 5; tput bold)
TXT_ERROR=$(tput setaf 1)
TXT_FAIL=$(tput setab 1; tput bold)
TXT_PROMPT=$(tput setaf 3)


##############################################################################
main()
##############################################################################
{
  # notify when any command fails
  add_on_err 'printf "\n${TXT_FAIL}*****  $COMMAND FAILED  *****${TXT_NORMAL}\n\n"'

  get_options "$@"

  # move operand pointer past any options & reset OPTIND
  shift $(($OPTIND - 1))
  OPTIND=1

  if [ -n "$source_file" ]; then    # SOURCE_FILE mode:
    source_location=$source_file
    source_type="file"
    backup_source=false
    get_operands_source_file "$@"
  else    # SOURCE_DATABASE mode:
    source_location=$source_db
    source_type="database"
    backup_source=true
    get_operands_source_database "$@"
  fi

  set_common_variables    # sets Comment, Username, Password, & Date

  check_db_connection
  prod_db_overwrite_test "a $source_type ('$source_location')"
  if $backup_source; then
    backup_source_db    # sets $source_db_output
    source_file=$source_db_output
  fi
  backup_destination_db
  create_destination_db
  copy_source_to_destination_db "$source_file"

  # output line break for aesthatic purposes
  printf "\n"
}


##############################################################################
help_prompt()
##############################################################################
{
  printf "${TXT_NOTICE}Try \`$COMMAND -h' for more information${TXT_NORMAL}\n"
}


##############################################################################
usage()
##############################################################################
{
cat << EOF
usage: $COMMAND [OPTION]... SOURCE_DATABASE [DESTINATION_DATABASE]
       $COMMAND [OPTION]... -s SOURCE_FILE DESTINATION_DATABASE

DESCRIPTION:
   $COMMAND
      Backup of MySQL database from SOURCE_DATABASE and optionally copy to DESTINATION_DATABASE

   $COMMAND -s
      Copy SOURCE_FILE to DESTINATION_DATABASE

OPTIONS:
   -h                show this Help message
   -s <SOURCE_FILE>  copy from Source file to DESTINATION_DATABASE
   -c <COMMENT>      Comment to add to filename (default: <none>)
   -u <USERNAME>     database Username (default: root)
   -p <PASSWORD>     database Password (default: <prompt>)
   -p ''             database Password is not set (or null)
   -b                use Bzip2 to compress output
   -g                use Gzip to compress output
   -n                dry run - do Not actually do anything, just show what would be done
EOF
}


##############################################################################
get_options()
##############################################################################
{
  while getopts ":hs:c:u:p:bgn" opt; do
    case $opt in
      h)
        usage
        exit
        ;;
      s)
        source_file=$OPTARG
        ;;
      c)
        comment=$OPTARG
        ;;
      u)
        username=$OPTARG
        ;;
      p)
        password=$OPTARG
        ;;
      b)
        bzip2=TRUE
        ;;
      g)
        gzip=TRUE
        ;;
      n)
        dry_run=TRUE
        ;;
      \?)
        printf "${TXT_ERROR}$COMMAND: Invalid option: -$OPTARG${TXT_NORMAL}\n"
        help_prompt
        exit $E_OPTION_ERROR
        ;;
      :)
        printf "${TXT_ERROR}$COMMAND: Option -$OPTARG requires an argument.${TXT_NORMAL}\n"
        help_prompt
        exit $E_OPTION_ERROR
        ;;
    esac
  done
}


##############################################################################
get_operands_source_file()
##############################################################################
{
  # check for the right # of arguments
  case $# in
    0)
      printf "${TXT_ERROR}$COMMAND: missing DESTINATION_DATABASE operand${TXT_NORMAL}\n"
      help_prompt
      exit $E_OPTION_ERROR
      ;;
    1)
      destination_db=$1
      ;;
    *)
      printf "${TXT_ERROR}$COMMAND: too many operands${TXT_NORMAL}\n"
      help_prompt
      exit $E_OPTION_ERROR
      ;;
  esac
}


##############################################################################
get_operands_source_database()
##############################################################################
{
  # check for the right # of arguments
  case $# in
    0)
      printf "${TXT_ERROR}$COMMAND: missing SOURCE_DATABASE operand${TXT_NORMAL}\n"
      help_prompt
      exit $E_OPTION_ERROR
      ;;
    1)
      source_db=$1
      destination_db=
      ;;
    2)
      source_db=$1
      destination_db=$2
      ;;
    *)
      printf "${TXT_ERROR}$COMMAND: too many operands${TXT_NORMAL}\n"
      help_prompt
      exit $E_OPTION_ERROR
      ;;
  esac
}


##############################################################################
prod_db_overwrite_test()
##############################################################################
{
  source_comment=$1

  if [[ $destination_db =~ '_prod' ]]; then
    printf "\n${TXT_WARNING}*******************************************************************************\n"
    printf "*                            !!!!!  WARNING !!!!!                             *\n"
    printf "*                                                                             *\n"
    printf "* This script will overwrite a PRODUCTION database ($destination_db)\n"
    printf "* with the contents of $source_comment.\n"
    printf "*                                                                             *\n"
    printf "* Are you sure you want to do this?  If so, confirm by entering \"CONFIRM\" in  *\n"
    printf "* all caps (without the quotes) at the prompt below.                          *\n"
    printf "*******************************************************************************${TXT_NORMAL}\n"
    printf "\n"
    read -p "${TXT_PROMPT}Are you sure? ${TXT_NORMAL}" confirm

    if [ $confirm != "CONFIRM" ]; then
      printf "\n${TXT_ERROR}## Exiting program without making any changes${TXT_NORMAL}\n\n"
      exit 1
    fi
  fi
}


##############################################################################
set_common_variables()
##############################################################################
{
  set_comment_out
  set_db_username
  set_db_password
  set_db_password_out
  set_date
}


##############################################################################
set_comment_out()
##############################################################################
{
  # if comment is set & not empty, create the comment output
  if [ -n "$comment" ]; then
    comment_out=".\"$comment\""
  fi
}


##############################################################################
set_db_username()
##############################################################################
{
  # set DB username to "root" if not set with -u option
  if [ -n "$username" ]; then
    db_username=$username
  else
    db_username="root"
  fi
}


##############################################################################
set_db_password()
##############################################################################
{
  # get & set DB password if not set with -p option
  if [ -n "$password" ]; then
    db_password=$password
  elif [ -n "${password+isSet}" ]; then
    db_password=
  else
    printf "\n"
    read -s -p "${TXT_PROMPT}DB Password for user '$db_username': ${TXT_NORMAL}" db_password
    printf "\n"
  fi
}


##############################################################################
set_db_password_out()
##############################################################################
{
  # if db_password is set & not empty, create the password output (use "-p")
  # include space in front, so it will be separated from the username output
  if [ -n "$db_password" ]; then
    db_password_out=" -p'$db_password'"
    db_password_out_hidden=" -p'<password>'"
  else
    db_password_out=
    db_password_out_hidden=
  fi
}


##############################################################################
set_date()
##############################################################################
{
  # get & set the date
  date=$(date +%F.%T)
}


##############################################################################
on_exit()
##############################################################################
{
  for i in "${on_exit_items[@]}"; do
    eval $i
  done
}


##############################################################################
add_on_exit()
##############################################################################
{
  local n=${#on_exit_items[*]}
  on_exit_items[$n]="$*"
  if [[ $n -eq 0 ]]; then
    trap on_exit EXIT
  fi
}


##############################################################################
on_err()
##############################################################################
{
  exitCode=$?

  if [[ $exitCode == 5 ]]; then
    for i in "${on_err_items[@]}"; do
      eval $i
    done
  fi

  exit $exitCode
}


##############################################################################
add_on_err()
##############################################################################
{
  local n=${#on_err_items[*]}
  on_err_items[$n]="$*"
  if [[ $n -eq 0 ]]; then
    set -E -o pipefail
    trap on_err EXIT
  fi
}


##############################################################################
output_command()
##############################################################################
{
  command=$1
  outfile=$2

  if [ -n "$outfile" ]; then
    command="$command > $outfile"
  fi

  command_out=${command//'<password>'/$db_password_out_hidden}

  printf "${TXT_PROMPT}> ${TXT_NORMAL}${TXT_COMMAND}$command_out${TXT_NORMAL}\n"
}


##############################################################################
_run_command()
##############################################################################
{
  command=$1

  command_run=${command/'<password>'/$db_password_out}

  if [ -n "$dry_run" ]; then
    printf "${TXT_NOTICE}  -- DRY RUN -- No Command Run${TXT_NORMAL}\n"
  else
    eval "$command_run" &
    pid=$!

    printf " "
    rotate='|/-\'

    while kill -n 0 $pid 2>/dev/null; do
      rotate="${rotate#?}${rotate%???}"
      printf '%.1s\b' "$rotate"
      sleep 0.125
    done

    printf "\b"
    wait $pid
  fi
}


##############################################################################
run_command()
##############################################################################
{
  command=$1
  outfile=$2
  error_handling=$3
  fail_command=$4

  if [ -n "$outfile" ]; then
    command="$command > $outfile"
  fi

  if [ -n "$fail_command" ]; then
    add_on_err $fail_command
  fi

  _run_command "$command"
  return_code=$?

  if [ $error_handling != "silent" ]; then
    if [ $return_code -eq "0" ]; then
      printf "${TXT_SUCCESS}###   [ PASS ]   ###${TXT_NORMAL}\n"
    else
      printf "${TXT_ERROR}###   [ FAIL ]   ###${TXT_NORMAL}\n"
      if [ "$error_handling" == "fail" ]; then
        exit 5    # Trap Error & Exit
      fi
    fi
  fi

  return $return_code
}


##############################################################################
output_filename()
##############################################################################
{
  backup_type=$1
  database=$2

  output_filename="output.$backup_type:\"$database\".$date$comment_out.sql"

  echo $output_filename
}


##############################################################################
optionally_compress_file()
##############################################################################
{
  filename=$1

  if [ -n "$bzip2" ]; then
    command="bzip2 $original_file"

    printf "\n${TXT_NOTICE}## Compressing file with bzip2: \"$filename\"${TXT_NORMAL}\n"
    output_command "$command"
    run_command "$command" "" "fail"

  elif [ -n "$gzip" ]; then
    command="gzip $original_file"

    printf "\n${TXT_NOTICE}## Compressing file with gzip: \"$filename\"${TXT_NORMAL}\n"
    output_command "$command"
    run_command "$command" "" "fail"
  fi
}



##############################################################################
redirect_to_output()
##############################################################################
{
  output_file=$1
  redirection=""

  if [ -n "$bzip2" ]; then
    redirection="| bzip2 -c "
  elif [ -n "$gzip" ]; then
    redirection="| gzip -c "
  fi

  redirection_output="$redirection> '$output_file'"

  echo $redirection_output
}


##############################################################################
redirect_from_input()
##############################################################################
{
  input_file=$1
  mime_type=$(file -ib "$1")

  case $mime_type in
    *text/plain*)
      input_process="cat"
      ;;
    *bzip*)
      input_process="bzip2 -dc"
      ;;
    *gzip*)
      input_process="gzip -dc"
      ;;
    *)
      printf "\n${TXT_ERROR}$COMMAND: input format not supported${TXT_NORMAL}\n"
      help_prompt
      exit $E_INPUT_TYPE_ERROR
      ;;
  esac

  redirection_input="${input_process} '$input_file'"

  echo $redirection_input
}


##############################################################################
backup_source_db()
##############################################################################
{
  # set source output filename
  source_db_output=$(output_filename 'source' "$source_db")

  command="mysqldump -u '$db_username'<password> '$source_db' > $source_db_output"

  printf "\n\n${TXT_NOTICE}## Creating dump of source database: \"$source_db\"${TXT_NORMAL}\n"

  output_command "$command" "$source_db_output"
  run_command "$command" "$source_db_output" "fail" "rm -f $source_db_output"

  optionally_compress_file "$source_db_output"
}


##############################################################################
check_db_connection()
##############################################################################
{
  # check if destination database exists
  command="mysql --batch --skip-column-names -u '$db_username'$db_password_out -e 'connect'"

  printf "\n\n${TXT_NOTICE}## Checking database connection...${TXT_NORMAL}\n"

  run_command "$command" "" "fail"
}


##############################################################################
check_for_destination_db()
##############################################################################
{
  # check if destination database exists
  command="mysql --batch --skip-column-names -u '$db_username'$db_password_out -e 'SHOW DATABASES LIKE \"$destination_db\"' | grep -q '$destination_db'"

  printf "\n\n${TXT_NOTICE}## Checking if destination database exists: \"$destination_db\"${TXT_NORMAL}\n"

  run_command "$command" "" "silent"
  return_code=$?

  if [ "$return_code" -eq "0" ]; then
    printf "${TXT_NOTICE}## Destination database exists${TXT_NORMAL}\n"
    return 0
  else
    printf "${TXT_NOTICE}## Destination database does not exist${TXT_NORMAL}\n"
    return 1
  fi
}


##############################################################################
backup_destination_db()
##############################################################################
{
  check_for_destination_db

  if [ "$?" -eq "0" ]; then
    # set destination output filename
    destination_db_output=$(output_filename 'destination' "$destination_db")

    command="mysqldump -u '$db_username'<password> '$destination_db' > $destination_db_output"

    printf "${TXT_NOTICE}## Backing up: \"$destination_db\"${TXT_NORMAL}\n"

    output_command "$command" "$destination_db_output"
    run_command "$command" "$destination_db_output" "fail" "rm -f $destination_db_output"

    optionally_compress_file "$destination_db_output"

  else
    printf "${TXT_NOTICE}## Skipping backup${TXT_NORMAL}\n"
  fi
}


##############################################################################
create_destination_db()
##############################################################################
{
  command="mysql -u '$db_username'<password> -e 'DROP DATABASE IF EXISTS \`$destination_db\`; CREATE DATABASE \`$destination_db\` DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;'"

  printf "\n\n${TXT_NOTICE}## Creating empty destination database: \"$destination_db\"${TXT_NORMAL}\n"

  output_command "$command"
  run_command "$command" "" "fail"
}


##############################################################################
copy_source_to_destination_db()
##############################################################################
{
  source_db_file=$1

  command="$(redirect_from_input "$source_db_file") | mysql -u '$db_username'<password> '$destination_db'"

  printf "\n\n${TXT_NOTICE}## Copying source database dump to destination database: \"$destination_db\"${TXT_NORMAL}\n"

  output_command "$command" "$outfile"
  run_command "$command" "$outfile" "fail" "rm -f $outfile"
}


##############################################################################
# call main function
##############################################################################

main "$@"
